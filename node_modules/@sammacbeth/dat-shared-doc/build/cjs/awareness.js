"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lib0_1 = require("lib0");
const y_protocols_1 = require("y-protocols");
const messageQueryAwareness = 3;
const messageAwareness = 1;
class AwarenessExtension {
    constructor(doc, multicore, awareness = new y_protocols_1.Awareness(doc)) {
        this.multicore = multicore;
        this.awareness = awareness;
        const self = this;
        this.ext = multicore.rootFeed.registerExtension("y-awareness", {
            encoding: "binary",
            onmessage(message, peer) {
                const decoder = lib0_1.decoding.createDecoder(message);
                const encoder = lib0_1.encoding.createEncoder();
                const messageType = lib0_1.decoding.readVarUint(decoder);
                let sendReply = false;
                switch (messageType) {
                    case messageQueryAwareness:
                        lib0_1.encoding.writeVarUint(encoder, messageAwareness);
                        lib0_1.encoding.writeVarUint8Array(encoder, y_protocols_1.encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())));
                        sendReply = true;
                        break;
                    case messageAwareness:
                        y_protocols_1.applyAwarenessUpdate(awareness, lib0_1.decoding.readVarUint8Array(decoder), this);
                        break;
                }
                if (sendReply) {
                    self.ext.send(Buffer.from(lib0_1.encoding.toUint8Array(encoder)), peer);
                }
            },
        });
        const _awarenessChangeHandler = ({ added, updated, removed }) => {
            const changedClients = added.concat(updated).concat(removed);
            const encoderAwareness = lib0_1.encoding.createEncoder();
            lib0_1.encoding.writeVarUint(encoderAwareness, messageAwareness);
            lib0_1.encoding.writeVarUint8Array(encoderAwareness, y_protocols_1.encodeAwarenessUpdate(this.awareness, changedClients));
            this.ext.broadcast(Buffer.from(lib0_1.encoding.toUint8Array(encoderAwareness)));
        };
        awareness.on("change", _awarenessChangeHandler);
        const _syncPeerHandler = (peer) => {
            const awarenessStates = awareness.getStates();
            if (awarenessStates.size > 0) {
                const encoder = lib0_1.encoding.createEncoder();
                lib0_1.encoding.writeVarUint(encoder, messageAwareness);
                lib0_1.encoding.writeVarUint8Array(encoder, y_protocols_1.encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())));
                self.ext.send(Buffer.from(lib0_1.encoding.toUint8Array(encoder)), peer);
            }
        };
        this.multicore.rootFeed.on("peer-add", _syncPeerHandler);
    }
}
exports.default = AwarenessExtension;
