"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const feed_announce_1 = require("./feed-announce");
const multicore_1 = require("./multicore");
exports.Multicore = multicore_1.Multicore;
const ydoc_1 = require("./ydoc");
exports.YDocHandler = ydoc_1.default;
const awareness_1 = require("./awareness");
const bootstrap_1 = require("./bootstrap");
const DOC_NAME = 'ydoc';
class DatYDoc {
    constructor(root, store, opts) {
        this.store = store;
        this.opts = opts;
        this.multicore = new multicore_1.Multicore(root, store);
        const docHandler = new ydoc_1.default(DOC_NAME);
        this.multicore.addHandler(docHandler);
        this.doc = docHandler.doc;
        this.key = this.multicore.key;
        this.ready = new Promise(async (resolve) => {
            await this.multicore.ready(multicore_1.METADATA_NAME);
            if (this.isAdmin && !this.writable) {
                await this.multicore.authorise(DOC_NAME, this.multicore.getFeed(DOC_NAME).key);
            }
            this.discoveryKey = this.multicore.discoveryKey;
            if (!this.isAdmin && !this.writable) {
                this.multicore.on("writer", (type) => {
                    if (type === multicore_1.METADATA_NAME && !this.writable) {
                        this.multicore.authorise(DOC_NAME, this.multicore.getFeed(DOC_NAME).key);
                    }
                });
                if (opts.announceFeeds) {
                    this.feedAnnouncer.enable();
                }
            }
            resolve();
        });
        // extension to find out about new feeds
        if (opts.announceFeeds) {
            this.feedAnnouncer = new feed_announce_1.default(this.multicore);
            this.feedAnnouncer.on("feeds", (feeds) => {
                if (this.isAdmin) {
                    if (opts.policy === "GRANT_ALL_ADMIN" && feeds.metadata) {
                        this.multicore.authorise(multicore_1.METADATA_NAME, feeds.metadata);
                    }
                    else if (opts.policy === "GRANT_ALL_WRITER" && feeds[DOC_NAME]) {
                        this.multicore.authorise(DOC_NAME, feeds[DOC_NAME]);
                    }
                }
            });
        }
        if (opts.awareness) {
            this.awareness = new awareness_1.default(this.multicore.metadataHandler.doc, this.multicore);
        }
        if (opts.bootstrapEnabled) {
            this.feedBootstrapper = new bootstrap_1.default(this.multicore);
        }
    }
    static create(store, opts) {
        return new Promise((resolve) => {
            store.ready(() => {
                resolve(new DatYDoc(store.namespace(multicore_1.METADATA_NAME).default().key, store, opts));
            });
        });
    }
    static load(key, store, opts) {
        return new Promise((resolve) => {
            store.ready(() => {
                resolve(new DatYDoc(Buffer.from(key, "hex"), store, opts));
            });
        });
    }
    docReady() {
        return this.multicore.ready(DOC_NAME);
    }
    get writable() {
        return this.multicore.isWriter(DOC_NAME);
    }
    get isAdmin() {
        return this.multicore.isAdmin;
    }
    async close() {
        if (this.announceTimer) {
            clearTimeout(this.announceTimer);
        }
    }
}
exports.DatYDoc = DatYDoc;
