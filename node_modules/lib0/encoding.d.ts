/**
 * A BinaryEncoder handles the encoding to an Uint8Array.
 */
export class Encoder {
    cpos: number;
    cbuf: Uint8Array;
    /**
     * @type {Array<Uint8Array>}
     */
    bufs: Array<Uint8Array>;
}
export function createEncoder(): Encoder;
export function length(encoder: Encoder): number;
export function toUint8Array(encoder: Encoder): Uint8Array;
export function write(encoder: Encoder, num: number): void;
export function set(encoder: Encoder, pos: number, num: number): void;
export function writeUint8(encoder: Encoder, num: number): void;
export function setUint8(encoder: Encoder, pos: number, num: number): void;
export function writeUint16(encoder: Encoder, num: number): void;
export function setUint16(encoder: Encoder, pos: number, num: number): void;
export function writeUint32(encoder: Encoder, num: number): void;
export function setUint32(encoder: Encoder, pos: number, num: number): void;
export function writeVarUint(encoder: Encoder, num: number): void;
export function writeVarInt(encoder: Encoder, num: number): void;
export function writeVarString(encoder: Encoder, str: string): void;
export function writeBinaryEncoder(encoder: Encoder, append: Encoder): void;
export function writeUint8Array(encoder: Encoder, uint8Array: Uint8Array): void;
export function writeVarUint8Array(encoder: Encoder, uint8Array: Uint8Array): void;
export function writeOnDataView(encoder: Encoder, len: number): DataView;
export function writeFloat32(encoder: Encoder, num: number): void;
export function writeFloat64(encoder: Encoder, num: number): void;
export function writeBigInt64(encoder: Encoder, num: bigint): any;
export function writeBigUint64(encoder: Encoder, num: bigint): any;
export function writeAny(encoder: Encoder, data: string | number | bigint | boolean | any[] | Uint8Array | {
    [x: string]: any;
} | null | undefined): void;
//# sourceMappingURL=encoding.d.ts.map