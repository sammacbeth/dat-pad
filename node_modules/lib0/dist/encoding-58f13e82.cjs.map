{"version":3,"file":"encoding-58f13e82.cjs","sources":["../encoding.js"],"sourcesContent":["/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\nimport * as string from './string.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num >>>= 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  let isNegative = false\n  if (num < 0) {\n    num = -num\n    isNegative = true\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num >>>= 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num >>>= 7\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeVarString = (encoder, str) =>\n  writeVarUint8Array(encoder, string.encodeUtf8(str))\n\n/**\n * Write the content of another Encoder.\n *\n * TODO: can be improved!\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && data <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n"],"names":["buffer.createUint8ArrayViewFromArrayBuffer","math.max","binary.BITS8","binary.BITS7","binary.BIT8","binary.BITS6","binary.BIT7","string.encodeUtf8","math.min","number.isInteger","binary.BITS31"],"mappings":"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"}